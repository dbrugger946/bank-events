

# Maximum Java heap to be used during the native image generation
quarkus.native.native-image-xmx=4g


# quarkus.kubernetes-client.trust-certs=true

# quarkus.s2i.base-jvm-image=registry.access.redhat.com/openjdk/openjdk-11-rhel7

# quarkus.http.port=9090

quarkus.swagger-ui.always-include=true

# quarkus.openshift.expose=true

# quarkus.openshift.labels.app=app-name

quarkus.test.continuous-testing=disabled

# DEV Configure the Kafka sink (we write to it)
%dev.mp.messaging.outgoing.kogito_outgoing_stream.bootstrap.servers=localhost:9092 
%dev.mp.messaging.outgoing.kogito_outgoing_stream.group.id=customer-event-analysis
%dev.mp.messaging.outgoing.kogito_outgoing_stream.connector=smallrye-kafka
%dev.mp.messaging.outgoing.kogito_outgoing_stream.topic=offer-output-stream
%dev.mp.messaging.outgoing.kogito_outgoing_stream.value.serializer=org.apache.kafka.common.serialization.StringSerializer

# DEV Configure the Kafka source (we read from it)
%dev.mp.messaging.incoming.kogito_incoming_stream.bootstrap.servers=localhost:9092
%dev.mp.messaging.incoming.kogito_incoming_stream.group.id=customer-event-analysis
%dev.mp.messaging.incoming.kogito_incoming_stream.connector=smallrye-kafka
%dev.mp.messaging.incoming.kogito_incoming_stream.topic=event-input-stream
%dev.mp.messaging.incoming.kogito_incoming_stream.value.deserializer=org.apache.kafka.common.serialization.StringDeserializer


